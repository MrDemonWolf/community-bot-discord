# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Community Discord bot for MrDemonWolf, Inc. Built with TypeScript, discord.js v14, Express API, Prisma ORM (PostgreSQL), BullMQ job queue (Redis), and Zod environment validation. ESM modules throughout (`"type": "module"`).

Features include Twitch live stream notifications (polling Helix API, sending/editing Discord embeds), slash commands (`/twitch` with subcommands), background job scheduling, and automatic guild database sync.

## Commands

```bash
pnpm dev                  # Run in dev mode with hot reload (tsx watch)
pnpm build                # Clean build: rm dist/ then tsc
pnpm start                # Run production build (node dist/app.js)
pnpm lint                 # ESLint with auto-fix
pnpm format               # Prettier + ESLint formatting
pnpm test                 # Mocha tests (cross-env NODE_ENV=test)
pnpm prisma:sync          # Sync schema from monorepo (../community-bot)
pnpm prisma:generate      # Generate Prisma client (outputs to src/generated/prisma/)
pnpm prisma:migrate       # Run database migrations (prisma migrate deploy)
pnpm prisma:push          # Push schema changes directly to database
pnpm prisma:studio        # Open Prisma visual database editor
```

## Prisma Schema

**DO NOT edit `prisma/schema.prisma` directly.** The source of truth for all Prisma models is the monorepo at `../community-bot/packages/db/prisma/schema/`. The local schema is generated by `scripts/sync-prisma.sh`.

To sync after schema changes in the monorepo:
```bash
pnpm prisma:sync              # Pull models from monorepo -> prisma/schema.prisma
pnpm prisma:generate          # Regenerate the Prisma client
```

This project owns the migration history. After schema changes:
```bash
pnpm prisma:sync && pnpm prisma:generate && pnpm prisma:migrate
```

The monorepo splits models into domain files:
- `discord.prisma` — DiscordGuild (with notificationChannelId, notificationRoleId)
- `twitch.prisma` — TwitchChannel, TwitchNotification, TwitchCredential, TwitchChatCommand, TwitchRegular, enums
- `queue.prisma` — QueueEntry, QueueState, QueueStatus
- `auth.prisma` — User, Session, Account (web app only, not synced here)

The sync script (`scripts/sync-prisma.sh`) pulls only the files listed in its `SCHEMA_FILES` array (discord.prisma, twitch.prisma, queue.prisma), prepends the local generator config, and writes a single `prisma/schema.prisma`.

**Key schema details:**
- `TwitchChannel` uses compound unique `@@unique([twitchChannelId, guildId])` — always use `twitchChannelId_guildId` for unique lookups
- `TwitchNotification` tracks Discord message IDs for live/offline embed editing
- `DiscordGuild` stores per-guild notification channel and role settings

## Architecture

**Entry point:** `src/app.ts` — initializes four subsystems in sequence:
1. **Discord client** (discord.js) — logs in, registers event handlers, registers slash commands on ready
2. **BullMQ worker** — background job queue using Redis (queue name: `community-bot-jobs`)
3. **Prisma** — PostgreSQL connection via `@prisma/adapter-pg` (PrismaPg adapter)
4. **Express API** — health/status endpoints with helmet, cors, morgan middleware

**Key directories:**
- `src/events/` — Discord event handlers (ready, guildCreate, guildDelete, interactionCreate)
- `src/commands/` — Slash command registry and definitions
- `src/commands/twitch/` — `/twitch` command with subcommands (add, remove, list, test, notifications)
- `src/twitch/` — Twitch Helix API wrapper and Discord embed builders
- `src/worker/jobs/` — BullMQ job processors (setActivity, checkTwitchStreams)
- `src/api/routes/` — Express route handlers
- `src/utils/env.ts` — Zod-validated environment variables; all env access goes through the exported `env` object
- `src/database/index.ts` — Prisma client singleton using PrismaPg adapter
- `src/generated/prisma/` — Auto-generated Prisma client (do not edit manually)

**Database models** (Prisma): `DiscordGuild`, `TwitchChannel`, `TwitchNotification`, `TwitchCredential`, `TwitchChatCommand`, `TwitchRegular`, `QueueEntry`, `QueueState`

## Slash Commands

Commands are registered via `src/commands/index.ts` (a `Map<string, Command>`). The `ready` event registers them with Discord, and `interactionCreate` routes them.

| Command | Description |
|---------|-------------|
| `/twitch add <username>` | Validate Twitch user via Helix API, add to monitoring |
| `/twitch remove <username>` | Stop monitoring, delete associated notifications |
| `/twitch list` | Show monitored channels with live/offline status + config |
| `/twitch test <username>` | Owner-only: send fake live embed, auto-edit to offline after 10s |
| `/twitch notifications set-channel #channel` | Set notification channel for the guild |
| `/twitch notifications set-role @role` | Set notification role to mention |

All `/twitch` commands require `ManageGuild` permission except `/twitch test` which checks `OWNER_ID`.

## Twitch Integration

**API layer** (`src/twitch/api.ts`): Reads OAuth tokens from the `TwitchCredential` table (managed by the external Twitch bot service). Uses `TWITCH_CLIENT_ID` env var for the `Client-Id` header. Retries once on 401 (token may have been refreshed by the auth service). Provides `getTwitchUser()`, `getStreams()` (batches of 100), and `getStreamThumbnailUrl()`.

**Embeds** (`src/twitch/embeds.ts`): `buildLiveEmbed()` and `buildOfflineEmbed()` produce Discord embeds with purple (#9146FF) branding, stream info fields, thumbnail with cache-bust query param, and duration formatting.

**Polling job** (`src/worker/jobs/checkTwitchStreams.ts`): Runs every 90 seconds via BullMQ repeating job. Handles four transitions:
- **Offline -> Live**: Send notification embed, create `TwitchNotification` row
- **Still Live**: Edit existing embed with updated viewers/thumbnail/duration
- **Live -> Offline**: Edit embed to offline state, mark notification as not live
- **Still Offline**: No action

## TypeScript Configuration

- Target: ES2023, Module: NodeNext
- Strict mode with all additional checks enabled (`noUnusedLocals`, `noUnusedParameters`, `noImplicitReturns`, `noUncheckedIndexedAccess`, etc.)
- Path aliases configured: `@/*`, `@commands/*`, `@events/*`, `@utils/*`, `@database/*`, `@api/*` (mapped to `src/` subdirectories)
- All imports use `.js` extensions (required for NodeNext module resolution with ESM)

## Environment Setup

Copy `.env.example` to `.env`. Required variables: `DATABASE_URL`, `REDIS_URL`, `DISCORD_APPLICATION_ID`, `DISCORD_APPLICATION_PUBLIC_KEY`, `DISCORD_APPLICATION_BOT_TOKEN`, `OWNER_ID`, `MAIN_GUILD_ID`, `MAIN_CHANNEL_ID`, `TWITCH_CLIENT_ID`.

Optional: `DISCORD_DEFAULT_STATUS`, `DISCORD_DEFAULT_ACTIVITY_TYPE`, `DEFAULT_ACTIVITY_URL`, `DISCORD_ACTIVITY_INTERVAL_MINUTES`, `HOST`, `PORT`, `CORS_ORIGIN`, `VERSION`, `NODE_ENV`.

Docker Compose provides PostgreSQL and Redis: `docker compose up -d postgres redis` starts the infrastructure services.

## Patterns

- **Event handlers** are pure functions receiving discord.js event data, registered in `app.ts` via `client.on(Events.*)`.
- **Slash commands** follow a registry pattern: `src/commands/index.ts` exports a `Map<string, Command>`. Each command has `data` (SlashCommandBuilder) and `execute` (async handler). The `ready` event registers all commands with Discord, and `interactionCreate` looks up and executes them.
- **Guild database sync** happens on ready (prune stale guilds, ensure all current guilds exist), and on guildCreate/guildDelete events.
- **Background jobs** use BullMQ with Redis. Jobs are defined in `src/worker/jobs/`, routed by job name in `src/worker/index.ts`. Current jobs: `set-activity` (cron-based), `check-twitch-streams` (every 90s).
- **Logging** uses `consola` via `src/utils/logger.ts` which provides namespaced loggers (e.g., `logger.database.connected()`, `logger.api.started()`, `logger.discord.event()`, `logger.commands.success()`).
